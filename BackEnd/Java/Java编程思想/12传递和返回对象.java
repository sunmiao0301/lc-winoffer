本章宗旨是：认识在Java中 对象传递和赋值时所发生的一切
若读者是从某些特殊的程序设计环境中转移过来的，那么一般都会问到：“Java有指针吗？”有些人认为指针的操作很困难，而且十分危险，所以一厢情愿地认为它没有好处。同时由于Java有如此好的口碑，所以应该很轻易地免除自己以前编程中的麻烦，其中不可能夹带有指针这样的“危险品”。然而准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有“戒心”，运行期系统也不例外。或者换从另一个角度说，Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做“句柄”，但你可以把它想像成“安全指针”。和预备学校为学生提供的安全剪刀类似——除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。

12.1 传递句柄
好处在于Java中，多个引用都指向同一个对象。这使得我们可以将一个参数发给一个方法

12.1.1 别名问题
“别名” —— 多个句柄都试图指向同一个对象 一旦有人向那个对象里写入一点东西 但是其他句柄所有者却不希望那个对象改变

很少需要调用一个方法来处理它的参数；这叫作利用方法的“副作用”（Side Effect）。
所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。
由于存在这些混淆和缺陷，所以应该尽量避免改变参数。 
若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。

12.2 制作本地副本

12.2.1 按值传递

12.2.2 克隆对象

12.2.3 使类具有克隆能力 —— 尽管 clone() 是在 Object 类中定义的 但是在衍生类中仍不能直接使用

12.2.4 成功的克隆 

PS：
大家要记住这样一个事实：
Java对“是否等价”的测试并不对所比较对象的内部进行检查，从而核实它们的值是否相同。
==和!=运算符只是简单地对比句柄的内容。若句柄内的地址相同，就认为句柄指向同样的对象，所以认为它们是“等价”的。比较的是地址 是“指针” 而不是“指针”内容

12.2.5 Object.clone()的效果 —— 12.2.6 克隆合成对象
用RTTI判断欲克隆的对象的实际大小。采取这种方式，clone()方法便可建立起正确数量的存储空间，并对那个类型进行正确的按位复制。
但是实际上，需要为对象内每个句柄都明确调用一个clone()；否则那些句柄会别名变成原始对象的句柄。

12.3 克隆的控制 —— unseen

12.4 只读类
假如我们想让别名发挥积极的作用——禁止不必要的对象复制——但却不希望看到由此造成的副作用，那么又该如何处理呢？ 
一个办法是创建“不变对象”，令其从属于只读类。
可定义一个特殊的类，使其中没有任何方法能造成对象内部状态的改变。
在这样的一个类中，别名处理是没有问题的。
因为我们只能读取内部状态，所以当多处代码都读取相同的对象时，不会出现任何副作用。 
作为“不变对象”一个简单例子，Java的标准库包含了“封装器”（wrapper）类，可用于所有基本数据类型。

12.4.1 创建只读类

12.4.2 “一成不变”的弊端 —— 如果又需要变化，就必须进行新对象的创建工作，甚至频繁的垃圾收集。
对于某些类来说（比如String类），这一方案的代价显得太高了。
为解决这个问题，我们可以创建一个“同志”类，并使其能够修改。
以后只要涉及大量的修改工作，就可换为使用能修改的同志类。
完事以后，再切换回不可变的类。

对字串来说，这个同志类叫作StringBuffer，编译器可以自动创建一个StringBuffer，以便计算特定的表达式

12.4.4 String和StringBuffer类

12.5 总结
Java中每个对象都是在内存堆中创建的 
“别名问题”处理
1）克隆 来解决
2）创建“不可变”对象来处理

12.6 练习
(1) 创建一个myString类，在其中包含了一个String对象，以便用在构建器中用构建器的自变量对其进行初始化。添加一个toString()方法以及一个concatenate()方法，令其将一个String对象追加到我们的内部字串。在myString中实现clone()。创建两个static方法，每个都取得一个myString x句柄作为自己的自变量，并调用x.concatenate("test")。但在第二个方法中，请首先调用clone()。测试这两个方法，观察它们不同的结果。

(2) 创建一个名为Battery（电池）的类，在其中包含一个int，用它表示电池的编号（采用独一无二的标识符的形式）。接下来，创建一个名为Toy的类，其中包含了一个Battery数组以及一个toString，用于打印出所有电池。为Toy写一个clone()方法，令其自动关闭所有Battery对象。克隆Toy并打印出结果，完成对它的测试。

(3) 修改CheckCloneable.java，使所有clone()方法都能捕获CloneNotSupportException违例，而不是把它直接传递给调用者。

(4) 修改Compete.java，为Thing2和Thing4类添加更多的成员对象，看看自己是否能判断计时随复杂性变化的规律——是一种简单的线性关系，还是看起来更加复杂。

(5) 从Snake.java开始，创建Snake的一个深层复制版本。

